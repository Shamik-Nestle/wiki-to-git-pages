{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome To DSA And Algorithms Documentation Page","text":""},{"location":"#list-algorithms-we-will-cover","title":"List Algorithms we will cover","text":"<ul> <li>Binary Search</li> <li>Linear Search</li> </ul>"},{"location":"Data%20Structures%20and%20Algorithms/Binary%20Search/Theory/","title":"Theory","text":"<p>Binary search is a search algorithm used to find the position of a target value within a sorted array. It works by repeatedly dividing the search interval in half until the target value is found or the interval is empty. The search interval is halved by comparing the target element with the middle value of the search space.</p>"},{"location":"Data%20Structures%20and%20Algorithms/Binary%20Search/Theory/#conditions-to-apply-binary-search-algorithm-in-a-data-structure","title":"Conditions to apply Binary Search Algorithm in a Data Structure","text":"<p>To apply Binary Search algorithm:</p> <ol> <li>The data structure must be sorted.</li> <li>Access to any element of the data structure should take constant time.</li> </ol>"},{"location":"Data%20Structures%20and%20Algorithms/Binary%20Search/Theory/#binary-search-algorithm","title":"Binary Search Algorithm","text":"<p>Below is the step-by-step algorithm for Binary Search:</p> <ol> <li>Divide the search space into two halves by finding the middle index \u201cmid\u201d. </li> <li>Compare the middle element of the search space with the key. </li> <li>If the key is found at middle element, the process is terminated.</li> <li>If the key is not found at middle element, choose which half will be used as the next search space.</li> <li>If the key is smaller than the middle element, then the left side is used for next search.</li> <li>If the key is larger than the middle element, then the right side is used for next search.</li> <li>This process is continued until the key is found or the total search space is exhausted.</li> </ol>"},{"location":"Data%20Structures%20and%20Algorithms/Binary%20Search/Visualization/","title":"Visualization","text":""},{"location":"Data%20Structures%20and%20Algorithms/Binary%20Search%20Tree/Introduction/","title":"Introduction","text":"<p>A Binary Search Tree is a data structure used in computer science for organizing and storing data in a sorted manner. Each node in a Binary Search Tree has at most two children, a left child and a right child, with the left child containing values less than the parent node and the right child containing values greater than the parent node. This hierarchical structure allows for efficient searching, insertion, and deletion operations on the data stored in the tree.</p>"},{"location":"Data%20Structures%20and%20Algorithms/Linear%20Search/Theory/","title":"What is Linear Search Algorithm?","text":"<p>Linear search is a method for searching for an element in a collection of elements. In linear search, each element of the collection is visited one by one in a sequential fashion to find the desired element. Linear search is also known as sequential search.</p>"},{"location":"Data%20Structures%20and%20Algorithms/Linear%20Search/Theory/#algorithm-for-linear-search-algorithm","title":"Algorithm for Linear Search Algorithm:","text":"<p>The algorithm for linear search can be broken down into the following steps:</p> <p>Start: Begin at the first element of the collection of elements. Compare: Compare the current element with the desired element. Found: If the current element is equal to the desired element, return true or index to the current element. Move: Otherwise, move to the next element in the collection. Repeat: Repeat steps 2-4 until we have reached the end of collection. Not found: If the end of the collection is reached without finding the desired element, return that the desired element is not in the array.</p>"},{"location":"Data%20Structures%20and%20Algorithms/Linear%20Search/Theory/#how-does-linear-search-algorithm-work","title":"How Does Linear Search Algorithm Work?","text":"<p>In Linear Search Algorithm, Every element is considered as a potential match for the key and checked for the same. If any element is found equal to the key, the search is successful and the index of that element is returned. If no element is found equal to the key, the search yields \u201cNo match found\u201d.</p>"},{"location":"Data%20Structures%20and%20Algorithms/Linear%20Search/Time%20Complexity%20and%20Applications/","title":"Time Complexity","text":"<p>Best Case: In the best case, the key might be present at the first index. So the best case complexity is O(1)</p> <p>Worst Case: In the worst case, the key might be present at the last index i.e., opposite to the end from which the search has started in the list. So the worst-case complexity is O(N) where N is the size of the list.</p> <p>Average Case: O(N)</p> <p>Auxiliary Space: O(1) as except for the variable to iterate through the list, no other variable is used. </p> <p></p>"},{"location":"Data%20Structures%20and%20Algorithms/Linear%20Search/Time%20Complexity%20and%20Applications/#applications-of-linear-search-algorithm","title":"Applications of Linear Search Algorithm","text":"<ul> <li> <p>Unsorted Lists: When we have an unsorted array or list, linear search is most commonly used to find any element in the collection. Small Data Sets: Linear Search is preferred over binary search when we have small data sets with</p> </li> <li> <p>Searching Linked Lists: In linked list implementations, linear search is commonly used to find elements within the list. Each node is checked sequentially until the desired element is found. Simple Implementation: Linear Search is much easier to understand and implement as compared to Binary Search or Ternary Search.</p> </li> </ul>"},{"location":"Data%20Structures%20and%20Algorithms/Linked%20List/Operations%20in%20Linked%20List/","title":"Operations in Linked List","text":""},{"location":"Data%20Structures%20and%20Algorithms/Linked%20List/Operations%20in%20Linked%20List/#insertion-in-linked-list","title":"Insertion In Linked List","text":"<p>Given a Linked List, the task is to insert a new node in this given Linked List at the following positions: </p> <ol> <li>At the front of the linked list- To insert a new node at the front, we create a new node and point its next reference to the current head of the linked list. Then, we update the head to be this new node. This operation is efficient because it only requires adjusting a few pointers.</li> </ol> <p></p> <p>Algorithm:</p> <p>Make the first node of Linked List linked to the new node Remove the head from the original first node of Linked List Make the new node as the Head of the Linked List.</p> <p>Code-</p> <pre><code>// C++ Program to insert the node at the beginning of\n// Linked List\n\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nstruct Node {\n\n    int data;\n    Node* next;\n\n    Node(int new_data) {\n        data = new_data;\n        next = nullptr; \n    }\n};\n\n// Function to insert a new node at the beginning of the\n// list\nNode* insertAtFront(Node* head, int new_data) {\n\n    // Create a new node with the given data\n    Node* new_node = new Node(new_data);\n\n    // Make the next of the new node point to the current\n    // head\n    new_node-&gt;next = head;\n\n    // Return the new node as the new head of the list\n    return new_node;\n}\n\nvoid printList(Node* head) {\n\n    // Start from the head of the list\n    Node* curr = head;\n\n    // Traverse the list\n    while (curr != nullptr) {\n\n        // Print the current node's data\n        cout &lt;&lt; \" \" &lt;&lt; curr-&gt;data;\n\n        // Move to the next node\n        curr = curr-&gt;next;\n    }\n\n    // Print a newline at the end\n    cout &lt;&lt; endl;\n}\n\nint main() {\n\n    // Create the linked list 2-&gt;3-&gt;4-&gt;5\n    Node* head = new Node(2);\n    head-&gt;next = new Node(3);\n    head-&gt;next-&gt;next = new Node(4);\n    head-&gt;next-&gt;next-&gt;next = new Node(5);\n\n    int data = 1;\n    head = insertAtFront(head, data);\n    printList(head);\n\n    return 0;\n}\n\n</code></pre>"},{"location":"Data%20Structures%20and%20Algorithms/Linked%20List/Theory/","title":"Theory","text":"<p>A linked list is a linear data structure that consists of a series of nodes connected by pointers (in C or C++) or references (in Java, Python and JavaScript). Each node contains data and a pointer/reference to the next node in the list. Unlike arrays, linked lists allow for efficient insertion or removal of elements from any position in the list, as the nodes are not stored contiguously in memory.</p>"},{"location":"Data%20Structures%20and%20Algorithms/Linked%20List/Theory/#linked-lists-vs-arrays","title":"Linked Lists vs Arrays","text":""},{"location":"Data%20Structures%20and%20Algorithms/Linked%20List/Theory/#linked-list","title":"Linked List","text":"<ul> <li>Data Structure: Non-contiguous</li> <li>Memory Allocation: Typically allocated one by one to individual elements</li> <li>Insertion/Deletion: Efficient</li> <li>Access: Sequential</li> </ul>"},{"location":"Data%20Structures%20and%20Algorithms/Linked%20List/Theory/#array","title":"Array","text":"<ul> <li>Data Structure: Contiguous</li> <li>Memory Allocation: Typically allocated to the whole array</li> <li>Insertion/Deletion: Inefficient</li> <li>Access: Random</li> </ul>"},{"location":"Data%20Structures%20and%20Algorithms/Linked%20List/Theory/#types-of-linked-list","title":"Types of Linked List","text":"<ol> <li>Singly Linked List</li> <li>Doubly Linked List</li> <li>Circular Linked List</li> <li>Circular Doubly Linked List</li> <li>Header Linked List</li> </ol>"}]}